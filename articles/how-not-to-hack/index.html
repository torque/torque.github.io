<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>How not to be a Hacker - Incremental Evolution
    </title>
    <link rel="alternate" href="https://torque.github.io/feed.xml" type="application/rss+xml" title="">
    <link rel="stylesheet" href="/css/layout.css">
    <link rel="stylesheet" href="/css/tomorrow-night-eighties.css">
    <link rel="stylesheet" href="/css/article.css">
  </head>
  <body class="article-detail">
    <div class="body-wrap">
      <header class="header">
        <div class="content-wrap">
          <div class="logo">
            <h1><a href="/">Incremental Evolution</a></h1>
          </div>
        </div>
      </header>
      <div id="content">
        <div class="content-wrap">
          <article class="article">
            <h2 class="title">How not to be a Hacker</h2>
            <h3 class="date">Published December 18th, 2014 <span class="smallcaps">at</span> 15:45:58</h3>
            <section class="content"><p>The other day I decided I wanted to rip some CDs for, uh,
myself<a href="#fn:disclaimer" id="fnref:disclaimer" title="See footnote" class="footnote">1</a>. Because I am an unrepentant quality fiend, I was
compelled to ensure I produced accurate rips of the CDs. The go-to
program for this sort of thing on OS X is <a href="http://tmkk.undo.jp/xld/index_e.html">X Lossless Decoder</a>
(XLD), an application loaded to the brim with features for ensuring,
against all odds, that your CDs are accurately ripped.</p>

<p>Using XLD, I went through my collection and ripped upwards of twenty CDs
that I had ascertained had not been ripped before. Due to the required
quality of the rips, a single CD can take up to the real time length of
the CD to rip, as each song is actually read twice<a href="#fn:readtwice" id="fnref:readtwice" title="See footnote" class="footnote">2</a>, and for
some reason my CD drive would only run at 2x read speed instead of 6x on
some CDs. Needless to say, it took quite a bit of time to complete all
of them, and I was happy to be done when I finished.</p>

<p>That was when I found out that my perfect rips were flawed. XLD creates
log files that contain a log of the ripping process, including any
errors encountered, and for reliability purposes, I needed these logs to
be signed by XLD to verify that, uh, I hadn&#8217;t tampered with them. This
wouldn&#8217;t have been a problem if it weren&#8217;t for the fact that the log
signing plug-in for XLD is distributed separately and is not available
by default. None of my logs had been signed, and I wasn&#8217;t about to go
and waste the time re-ripping the CDs just to get some dumb verification
hash.</p>

<p>It was time to figure out how to get XLD to sign these logs after they
had already been created. Which, when you think about it, kind of
completely defeats the signing process, as it allows for the logs to be
modified before they are signed. Unlike the rest of XLD, the log signing
plug-in is not open source.</p>

<h3>Run, LogChecker, Run</h3>

<p>Let&#8217;s take the initial approach of writing a short Objective-C program
to load the log signing plug-in, which is distributed as a bundle. If we
can load it, we should be able to execute the signing code arbitrarily.</p>

<pre class="language-objectivec hljs"><span class="line-number"><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span></span><code class="language-objectivec"><span class="hljs-preprocessor">#import <span class="hljs-title">&lt;Foundation/Foundation.h&gt;</span></span>
<span class="hljs-preprocessor">#import <span class="hljs-title">&lt;Cocoa/Cocoa.h&gt;</span></span>
<span class="hljs-preprocessor">#import <span class="hljs-title">"XLDLogChecker.h"</span></span>

<span class="hljs-keyword">int</span> main( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv ) {
    <span class="hljs-built_in">NSBundle</span> *logCheckerBundle = [<span class="hljs-built_in">NSBundle</span> bundleWithPath:[@<span class="hljs-string">"~/Library/Application Support/XLD/PlugIns/XLDLogChecker.bundle"</span> stringByExpandingTildeInPath]];

    <span class="hljs-keyword">if</span> ( ![logCheckerBundle load] ) {
        <span class="hljs-built_in">NSLog</span>( @<span class="hljs-string">"Failed to load logChecker bundle."</span> );
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-built_in">NSMutableString</span> *logString = [[<span class="hljs-built_in">NSMutableString</span> alloc] initWithString:@<span class="hljs-string">"I am a log file. Sign me."</span>];

    Class logChecker = NSClassFromString( @<span class="hljs-string">"XLDLogChecker"</span> );

    <span class="hljs-keyword">if</span> ( logChecker ) {
        [logChecker appendSignature:logString];
        <span class="hljs-built_in">NSLog</span>( @<span class="hljs-string">"%@"</span>, logString );
    }

    [logCheckerBundle release];
    [logString release];

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>This program has an unexpected result: it crashes somewhere in the
LogChecker code. Looking at the XLD source doesn&#8217;t reveal any
information about why it wouldn&#8217;t work. It&#8217;s time to pull out the big
guns.</p>

<h3>Get Dissed, Assembler</h3>

<p>The big guns, as it were, consist of <a href="http://hopperapp.com">Hopper</a>, a
disassembler/decompiler for OS X. It is sold for the bargain basement
price of $90, which may sound like a lot until you consider that the
heavy hitter in the disassembly field, <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA</a>, starts at $450,
and that&#8217;s for the basic version<a href="#fn:hexrays" id="fnref:hexrays" title="See footnote" class="footnote">3</a>.</p>

<p>There is a free demo version of Hopper available that is
feature-complete, as long as you don&#8217;t consider unimportant things like
being able to save or use the program for longer than thirty minutes at
a time to be features. I am not wealthy enough to justify blowing 90
bucks on a weekend project, so that&#8217;s the version that I used.</p>

<p>With our big gun equipped, we load up the binary and navigate to the
function showing up at the top of the stack trace in the crashes. We
can see clearly what the problem is:</p>

<pre><code>_qwkoj1298oquwqwea89oi32r87hf:
00000c34 push ebp                                ; XREF=+[XLDLogChecker appendSignature:]+59, -[XLDLogChecker validateData:]+632
00000c35 mov  ebp, esp
00000c37 push edi
00000c38 push esi                                ; argument #2
00000c39 push ebx                                ; argument #1
00000c3a call 0xc3f
00000c3f pop  ebx                                ; XREF=_qwkoj1298oquwqwea89oi32r87hf+6
00000c40 sub  esp, 0xcc
00000c46 mov  dword [ss:ebp+var_B0], eax
00000c4c mov  dword [ss:ebp+var_B4], edx
00000c52 mov  dword [ss:esp], 0xfffffffe         ; argument #1 for method imp___jump_table__dlsym
00000c59 lea  eax, dword [ds:ebx-0xc3f+0x3b96]   ; "dlsym"
00000c5f mov  dword [ss:esp++[IconedCell ]], eax
00000c63 call imp___jump_table__dlsym
00000c68 mov  ecx, 0x8
...
</code></pre>

<p>The problem is we never actually took the time to learn x86 assembly. As
it is, that load of hot nonsense is getting us a whole lot of nowhere,
so the only route forward is to click on the &#8220;help, I&#8217;m illiterate&#8221;
button, which pops up a friendly window with psuedocode&#8230; which is
better, but not by a whole lot.</p>

<p>If we were, somehow, to acquire a copy of IDA with Hex-Rays<a href="#fn:dangerzone" id="fnref:dangerzone" title="See footnote" class="footnote">4</a>,
we would probably find that it does a pretty good job decompiling the
code. It might even produce something that looks like this:</p>

<pre class="language-c hljs"><span class="line-number"><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span></span><code class="language-c"><span class="hljs-keyword">int</span> qwkoj1298oquwqwea89oi32r87hf&lt;eax&gt;(<span class="hljs-keyword">void</span> *a1&lt;eax&gt;, <span class="hljs-keyword">char</span> *a2&lt;edx&gt;)
{
    <span class="hljs-comment">/* snip (variable declarations) */</span>
    v15 = dlsym((<span class="hljs-keyword">void</span> *)<span class="hljs-number">0xFFFFFFFE</span>, <span class="hljs-string">"dlsym"</span>);
    v2 = dlsym((<span class="hljs-keyword">void</span> *)<span class="hljs-number">0xFFFFFFFE</span>, <span class="hljs-string">"uncompress"</span>);
    <span class="hljs-keyword">if</span> ( v2 ) {
        v3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4000</span>u);
        v17 = <span class="hljs-number">0x899</span>;
        v4 = v3;
        ((<span class="hljs-keyword">void</span> (__cdecl *)(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">int</span> *, _UNKNOWN *, <span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span>))v2)(v3, &amp;v17, &amp;temporary, <span class="hljs-number">2201</span>);
        ((<span class="hljs-keyword">void</span> (__cdecl *)(<span class="hljs-keyword">char</span> *))((<span class="hljs-keyword">char</span> *)v4 + <span class="hljs-number">10032</span>))(&amp;v14);
        v5 = objc_msgSend(v13, <span class="hljs-string">"length"</span>);
        v6 = objc_msgSend(v13, <span class="hljs-string">"bytes"</span>);
        ((<span class="hljs-keyword">void</span> (__cdecl *)(<span class="hljs-keyword">char</span> *, <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">void</span> *))((<span class="hljs-keyword">char</span> *)v4 + <span class="hljs-number">9712</span>))(&amp;v14, v6, v5);
        ((<span class="hljs-keyword">void</span> (__cdecl *)(<span class="hljs-keyword">char</span> *, _DWORD))((<span class="hljs-keyword">char</span> *)v4 + <span class="hljs-number">9840</span>))(&amp;v14, v16);
        <span class="hljs-built_in">free</span>(v4);
    }
    <span class="hljs-comment">/* snip (generating result) */</span>
    <span class="hljs-keyword">return</span> result;
}
</code></pre>

<p>Hey, that&#8217;s nearly readable. So what it seems to be doing is unpacking a
compressed section of the executable into memory, and then trying to
execute specific offsets in that memory block, and the first one is the
one that causes the crash.</p>

<h3>Gee, Does That Sound Like a Defensive Measure to You?</h3>

<p>Okay, obviously the author spent a little bit of time trying to make
sure that people would have a bit of trouble decompiling this plugin,
but we&#8217;re onto him now. We can excise that compressed blob from the
executable using <a href="http://ridiculousfish.com/hexfiend/">our favorite hex editor</a> and write some
code to mimic the uncompressing function to dump it to a file.</p>

<pre class="language-c hljs"><span class="line-number"><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span></span><code class="language-c"><span class="hljs-preprocessor">#include &lt;dlfcn.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>

<span class="hljs-keyword">int</span> main ( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv ) {
    <span class="hljs-keyword">void</span> *uncompress = dlsym( RTLD_DEFAULT, <span class="hljs-string">"uncompress"</span> );
    <span class="hljs-keyword">if</span> ( uncompress ) {
        <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">0x4000</span>, compressedSize = <span class="hljs-number">0x899</span>;
        <span class="hljs-keyword">void</span> *uncompressedBlob = <span class="hljs-built_in">malloc</span>( maxSize );
        <span class="hljs-keyword">void</span> *compressedBlob = <span class="hljs-built_in">malloc</span>( compressedSize );
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Max size is: %d\n"</span>, maxSize );

        FILE *blob = fopen( <span class="hljs-string">"blob"</span>, <span class="hljs-string">"r"</span> );
        fread( compressedBlob, compressedSize, <span class="hljs-number">1</span>, blob );
        ((<span class="hljs-keyword">void</span> (__cdecl *)(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>*, <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>))uncompress)( uncompressedBlob, &amp;maxSize, compressedBlob, compressedSize );

        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Max size is now: %d\n"</span>, maxSize );

        FILE *uBlob = fopen( <span class="hljs-string">"ublob"</span>, <span class="hljs-string">"w"</span> );
        fwrite( uncompressedBlob, maxSize, <span class="hljs-number">1</span>, uBlob );
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">puts</span>( <span class="hljs-string">"Idk what is going on."</span> );
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p>Now we can load up the uncompressed blob in Hopper and look up those
offsets that it was trying to execute (<code>0x2730</code>, <code>0x25F0</code>, and
<code>0x2670</code>). We can, but we won&#8217;t, because they&#8217;re a horrifying reminder
of why you shouldn&#8217;t execute memory, even if you aren&#8217;t bad
guy<a href="#fn:anditdumb" id="fnref:anditdumb" title="See footnote" class="footnote">5</a>.</p>

<h3>An Aside</h3>

<p>At this point, I decided to build XLD from source and discovered that my
build would crash when trying to run LogChecker. Some investigation of
the strings lying around in the uncompressed blob indicated a reference
to <code>dsa_pub.pem</code>, the public key file shipped with XLD. I suspect
LogChecker verifies that XLD was signed using this key, though I didn&#8217;t
go out of my way to try to confirm this. This check makes sense to me
because performing it would act as another security measure by
preventing LogChecker from working with any XLD build besides the
&#8220;official&#8221; one.</p>

<p>It turns out that at least part of the reason XLD (and the LogChecker
bundle) are built only 32-bit is that 64-bit executables on OS X have
the NX bit set on heap memory, meaning this obfuscation trick wouldn&#8217;t
work with a 64-bit executable<a href="#fn:oreven" id="fnref:oreven" title="See footnote" class="footnote">6</a>.</p>

<p>Finally, I was stumped. With no more ideas, I asked a friend if he had
any thoughts on where to go next. As it turns out, he did.</p>

<h3>Attack a Different Target</h3>

<p>Trying to decompile the code and figure out what was going on failed to
get us anywhere besides the realization that the obfuscation techniques
employed by the LogChecer code were above our level of reverse
engineering skill. From there, the logical next step, seeing as we are
unable to use the plug-in directly, is to force XLD to use it for us.</p>

<p>mach_inject is an insidious tool for OS X that allows a program to
inject code into a running process. Dropbox, for example, uses it to
integrate with Finder due to a lack of public APIs provided by Apple. I
believe the main use it serves for Dropbox is creating the context
menus. Naturally, it works just as well for things that might not be
quite as legitimate.</p>

<h3>To Make a Long Story Short</h3>

<p>mach_inject worked fine for injecting XLD. The problem is that
mach_inject is pretty inconvenient to use. Writing a separate
application to actually perform the code injection is required, and, on
top of that, the injection process either requires an administrator
password or a janky workaround involving some job privilege API. While
there is an example of this process included in the mach_inject
codebase, it&#8217;s still a lot more infrastructure than should be necessary
to accomplish this task.</p>

<h3>Quit Trying to be So Smart and Start Being Clever</h3>

<p>mach_inject is a tool for big boys, and to be honest, in this case it&#8217;s
kind of like trying open a package with a chainsaw. Sure, a chainsaw may
be more versatile than a knife in the grand scheme of cutting things,
but a lot of the time it makes more sense to just use the knife.
Confusing metaphors aside, this problem can be solved by something that
requires far less boilerplate than mach_inject.</p>

<p>XLD is open source. We know that it can load and execute bundles, and we
know that all the loaded bundles have access to each other&#8217;s code,
should they choose to use it. Source is a lot easier to read than
disassembly, so let&#8217;s take a look at XLD&#8217;s bundle loading process and
see if we notice anything.</p>

<pre class="language-objectivec hljs"><span class="line-number"><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span></span><code class="language-objectivec"><span class="hljs-comment">/* XLDPluginManager.m */</span>

- (<span class="hljs-keyword">id</span>)init {
    [<span class="hljs-keyword">super</span> init];
    plugins = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];
    <span class="hljs-built_in">NSMutableDictionary</span> *dic = [[<span class="hljs-built_in">NSMutableDictionary</span> alloc] init];

    <span class="hljs-built_in">NSFileManager</span> *fm = [<span class="hljs-built_in">NSFileManager</span> defaultManager];
    <span class="hljs-built_in">NSArray</span> *bundleArr = [fm directoryContentsAt:[@<span class="hljs-string">"~/Library/Application Support/XLD/PlugIns"</span> stringByExpandingTildeInPath]];
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-built_in">NSBundle</span> *bundle = <span class="hljs-literal">nil</span>;

    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;[bundleArr count];i++) {
        <span class="hljs-built_in">BOOL</span> isDir = <span class="hljs-literal">NO</span>;
        <span class="hljs-built_in">NSString</span> *bundlePath = [[@<span class="hljs-string">"~/Library/Application Support/XLD/PlugIns"</span> stringByExpandingTildeInPath] stringByAppendingPathComponent:[bundleArr objectAtIndex:i]];
        <span class="hljs-keyword">if</span>([fm fileExistsAtPath:bundlePath isDirectory:&amp;isDir] &amp;&amp; isDir &amp;&amp; [[bundlePath pathExtension] isEqualToString:@<span class="hljs-string">"bundle"</span>]) {
            bundle = [<span class="hljs-built_in">NSBundle</span> bundleWithPath:bundlePath];
            <span class="hljs-keyword">if</span>(bundle) {
                <span class="hljs-keyword">if</span>(![[bundle infoDictionary] objectForKey:@<span class="hljs-string">"NSPrincipalClass"</span>]) <span class="hljs-keyword">continue</span>;
                [dic setObject:bundlePath forKey:[[bundle infoDictionary] objectForKey:@<span class="hljs-string">"NSPrincipalClass"</span>]];
            }
        }
    }
    <span class="hljs-comment">/* snip (loading bundles from the XLD.app bundle) */</span>
    [plugins addObjectsFromArray:[[dic allValues]sortedArrayUsingSelector:<span class="hljs-keyword">@selector</span>(compare:)]];
}
</code></pre>

<p>It appears XLD is very secure and is perfectly willing to load all kinds
of code from a user-writable folder. The only checks it makes are that
each bundle it loads has a <code>NSPrincipalClass</code> key. Importantly, it
doesn&#8217;t do any reliability checking (at least not in this code), and it
sorts the bundles it finds alphabetically by their <code>NSPrincipalClass</code>
value. The bundle code isn&#8217;t actually loaded here, though, so we need to
look elsewhere to find that.</p>

<pre class="language-objectivec hljs"><span class="line-number"><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span></span><code class="language-objectivec"><span class="hljs-comment">/* XLDController.m */</span>
- (<span class="hljs-keyword">id</span>)init {
    <span class="hljs-comment">/* snip (initialization) */</span>
    XLDPluginManager *pluginManager = [[XLDPluginManager alloc] init];
    decoderCenter = [[XLDecoderCenter alloc] initWithPlugins:[pluginManager plugins]];
    <span class="hljs-comment">/* snip (initializing built-in classes) */</span>

    <span class="hljs-built_in">NSArray</span> *bundleArr = [pluginManager plugins];

    <span class="hljs-keyword">int</span> i;
    <span class="hljs-built_in">NSBundle</span> *bundle = <span class="hljs-literal">nil</span>;
    <span class="hljs-comment">/* snip (initializing built-in encoders) */</span>
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;[bundleArr count];i++) {
        bundle = [<span class="hljs-built_in">NSBundle</span> bundleWithPath:[bundleArr objectAtIndex:i]];
        <span class="hljs-keyword">if</span>(bundle) {
            <span class="hljs-keyword">if</span>([bundle load]) {
                <span class="hljs-keyword">if</span>([[bundle principalClass] conformsToProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">XLDOutput</span>)] &amp;&amp; [[<span class="hljs-title">bundle</span> <span class="hljs-title">principalClass</span>] <span class="hljs-title">canLoadThisBundle</span>]) {</span>
                    output = [[[bundle principalClass] alloc] init];
                    <span class="hljs-keyword">if</span>([output respondsToSelector:<span class="hljs-keyword">@selector</span>(configurations)]) [outputArr addObject:output];
                    [output release];
                }
            }
        }
    }
    <span class="hljs-comment">/* snip (special code for loading the updater bundle) */</span>
    ...
</code></pre>

<p><code>XLDController</code> runs the bundle loading code and immediately passes it
off to the decoderCenter. The decoder center loads the bundles that
conform to the <code>XLDDecoder</code> protocol, but doesn&#8217;t initialize them until
they are actually needed to open a file. All bundles that conform to the
<code>XLDOutput</code> protocol, however, are immediately initialized after being
loaded.</p>

<p>A quick review of where we are: it turns out that when it is launched,
XLD picks up any bundles placed in its PlugIn directory, sorts them by
name and then immediately initializes the principal class of all bundles
that subscribe to the <code>XLDOutput</code> protocol. Hopefully at this point you
can see where this is going.</p>

<p>It&#8217;s worth noting that the LogChecker bundle is not initialized in this
loop. It is actually initialized later, in
<code>applicationDidFinishLaunching</code>, presumably because it adds a menu item.</p>

<pre class="language-objectivec hljs"><span class="line-number"><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span></span><code class="language-objectivec">Class logChecker = (Class)objc_lookUpClass(<span class="hljs-string">"XLDLogChecker"</span>);
<span class="hljs-keyword">if</span>(logChecker) {
    NSMenuItem *logcheckerItem = [[NSMenuItem alloc] initWithTitle:LS(@<span class="hljs-string">"Log Checker..."</span>) action:<span class="hljs-keyword">@selector</span>(logChecker) keyEquivalent:@<span class="hljs-string">""</span>];
    [logcheckerItem setTarget:[[logChecker alloc] init]];
    [[[[NSApp mainMenu] itemAtIndex:<span class="hljs-number">0</span>] submenu] insertItem:logcheckerItem atIndex:<span class="hljs-number">6</span>];
    [[[[NSApp mainMenu] itemAtIndex:<span class="hljs-number">0</span>] submenu] insertItem:[NSMenuItem separatorItem] atIndex:<span class="hljs-number">7</span>];
    [logcheckerItem release];
}
</code></pre>

<p>If that&#8217;s all it takes to use it after it&#8217;s been loaded, we could
probably do this ourselves.</p>

<pre class="language-objectivec hljs"><span class="line-number"><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span></span><code class="language-objectivec"><span class="hljs-comment">/* Z.h */</span>
<span class="hljs-preprocessor">#import <span class="hljs-title">&lt;Foundation/Foundation.h&gt;</span></span>
<span class="hljs-preprocessor">#import <span class="hljs-title">"XLDOutput.h"</span></span>
<span class="hljs-preprocessor">#import <span class="hljs-title">"BigMoney.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Z</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">XLDOutput</span>&gt;</span>
- (instancetype)init;
<span class="hljs-keyword">@end</span>

<span class="hljs-comment">/* Z.m */</span>
<span class="hljs-preprocessor">#import <span class="hljs-title">"Z.h"</span></span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Z</span></span>
+ (<span class="hljs-built_in">NSString</span> *)pluginName { <span class="hljs-keyword">return</span> @<span class="hljs-string">"Z"</span>; }
+ (<span class="hljs-built_in">BOOL</span>)canLoadThisBundle { <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>; }
- (instancetype)init {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init] ) {
        [<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(noWhammies) toTarget:[BigMoney new] withObject:<span class="hljs-literal">nil</span>];
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}
<span class="hljs-comment">/* snip (function stubs for the XLDOutput protocol) */</span>
<span class="hljs-keyword">@end</span>
</code></pre>

<p>We decide to descriptively name our plug-in Z, because we want to ensure
that it gets loaded after <code>LogChecker</code>, and really, when you get right
down to it, there aren&#8217;t that many letters to choose from that come
after the letter &#8220;L&#8221;. At least there aren&#8217;t that many that are
sufficiently cool.</p>

<p>Well, it doesn&#8217;t actually matter if it gets loaded before or after
<code>LogChecker</code> because of what we&#8217;re doing. You may be saying to yourself,
&#8220;Hey, this bundle is just starting a new thread, not actually signing
logs. Why are we talking about it now?&#8221; You&#8217;re right, of course. I just
wanted to break up the huge code blocks a little bit.</p>

<p>The point of making the new thread is so that any work we do that may
take a nontrivial amount of time, like accessing the filesystem, doesn&#8217;t
stall the main XLD thread and block the application from launching. That
would be bad. Such a stall could be emulated by sticking
<code>usleep(10000000)</code> in the code. If it is placed in <code>Z.m</code>, XLD will
beachball for 10 seconds on startup. If it is placed in <code>BigMoney.m</code>,
which runs in its own thread, XLD does not stall at all.</p>

<pre class="language-objectivec hljs"><span class="line-number"><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span></span><code class="language-objectivec"><span class="hljs-comment">/* BigMoney.h */</span>
<span class="hljs-preprocessor">#import <span class="hljs-title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">BigMoney</span> : <span class="hljs-title">NSObject</span> {</span>
    Class _logChecker;
    <span class="hljs-built_in">NSFileManager</span> *_manager;
}

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>) Class logChecker;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSFileManager</span> *manager;

- (instancetype)init;
- (<span class="hljs-keyword">void</span>)noWhammies;
- (<span class="hljs-keyword">void</span>)signLogFile:(<span class="hljs-built_in">NSString</span>*)fileName;

<span class="hljs-keyword">@end</span>

<span class="hljs-comment">/* BigMoney.m */</span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BigMoney</span></span>

<span class="hljs-keyword">@synthesize</span> logChecker = _logChecker;
<span class="hljs-keyword">@synthesize</span> manager = _manager;

- (instancetype)init {
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init] ) {
        _logChecker = NSClassFromString( @<span class="hljs-string">"XLDLogChecker"</span> );
        _manager = [<span class="hljs-built_in">NSFileManager</span> defaultManager];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}

- (<span class="hljs-keyword">void</span>)noWhammies {
    <span class="hljs-keyword">if</span> ( [<span class="hljs-keyword">self</span> logChecker] ) {
        <span class="hljs-built_in">NSString</span> *logDir = @<span class="hljs-string">"/tmp/logsToSign"</span>;

        <span class="hljs-built_in">BOOL</span> isDirectory = <span class="hljs-literal">NO</span>;
        <span class="hljs-keyword">if</span> ( ![[<span class="hljs-keyword">self</span> manager] fileExistsAtPath:logDir isDirectory:&amp;isDirectory] ) {
            [[<span class="hljs-keyword">self</span> manager] createDirectoryAtPath:logDir withIntermediateDirectories:<span class="hljs-literal">NO</span> attributes:<span class="hljs-literal">nil</span> error:<span class="hljs-literal">nil</span>];
        }

        <span class="hljs-built_in">NSArray</span> *logDirList = [[<span class="hljs-keyword">self</span> manager] contentsOfDirectoryAtPath:logDir error:<span class="hljs-literal">nil</span>];

        <span class="hljs-keyword">if</span> ( logDirList ) {
            <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; [logDirList count]; ++i ) {
                <span class="hljs-built_in">NSString</span> *logPath = [logDir stringByAppendingPathComponent:logDirList[i]];
                [<span class="hljs-keyword">self</span> signLogFile:logPath];
            }
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">NSLog</span>( @<span class="hljs-string">"Log checker not loaded. Doing nothing."</span> );
    }
}

- (<span class="hljs-keyword">void</span>)signLogFile:(<span class="hljs-built_in">NSString</span>*)fileName {
    <span class="hljs-built_in">BOOL</span> isDirectory = <span class="hljs-literal">NO</span>;
    <span class="hljs-keyword">if</span> (   [[<span class="hljs-keyword">self</span> manager] fileExistsAtPath:fileName isDirectory:&amp;isDirectory]
        &amp;&amp;  !isDirectory
        &amp;&amp; [[fileName pathExtension] isEqualToString:@<span class="hljs-string">"log"</span>]
        &amp;&amp; ![fileName hasSuffix:@<span class="hljs-string">"-signed.log"</span> ] ) {
        <span class="hljs-built_in">NSMutableString</span> *logFileContents = [<span class="hljs-built_in">NSMutableString</span> stringWithContentsOfFile:fileName encoding:NSUTF8StringEncoding error:<span class="hljs-literal">nil</span>];
        <span class="hljs-keyword">if</span> ( logFileContents ) {
            <span class="hljs-built_in">NSLog</span>( @<span class="hljs-string">"Signing log file: %@"</span>, fileName );
            <span class="hljs-built_in">NSString</span> *signedLog = [[fileName stringByDeletingPathExtension] stringByAppendingString:@<span class="hljs-string">"-signed.log"</span>];
            [[<span class="hljs-keyword">self</span> logChecker] appendSignature:logFileContents];
            [logFileContents writeToFile:signedLog atomically:<span class="hljs-literal">NO</span> encoding:NSUTF8StringEncoding error:<span class="hljs-literal">nil</span>];
        }
    }
}
</code></pre>

<p>There&#8217;s nothing fancy going on here. We get a list of all the files in
the directory <code>/tmp/logsToSign</code>, loop through that list of files and do
some basic verification of filename (checking for the extension <code>.log</code>,
but not the suffix <code>-signed.log</code>, as we don&#8217;t want to sign a log twice).
We add all the matching files to a dictionary with each key being the
full path to the output file and the corresponding value being the
contents of that file. The output files have <code>-signed</code> appended to their
names.</p>

<p>To close things out, we loop over the dictionary, tell LogChecker to
append its signature, and write the signed files to disk.</p>

<p>A very basic proof-of-concept, but it works, and the only side-effect is
that it creates an unusable entry in the encoder configuration dropdown
menu. That&#8217;s a small price to pay, in my opinion.</p>

<h3>The Moral of the Story</h3>

<p>My initial plan was to use the LogChecker plug-in to sign logs, and when
it failed to work, I continued pursuing the notion that I could make it
work for me, rather than stepping back and taking a look at the problem
as a whole. If injecting code into XLD hadn&#8217;t been brought up by someone
else, I may have given up completely, and at the very least I would have
taken a lot longer to arrive at a working solution.</p>

<p>It&#8217;s worth noting that although the LogChecker plug-in itself was
apparently designed to be secure against abuse, XLD itself was not. The
log checker was easily exploitable not due to its own fault but because
of the program using it.</p>

<h3>Final Thoughts</h3>

<p>Besides just appending signatures to log files that had already been
created, I had another motive for wanting to do this. XLD writes the
full path of each output file to the log file. If someone else were to
somehow get their hands on my log files, they could end up knowing
intimate details about the organization of my filesystem hierarchy, and
that would be terrible.</p>

<p>Ultimately, maybe that does count as fraud, but I wasn&#8217;t editing the log
files to change any of the actually important information. A less
scrupulous individual than myself may be inclined to sign more heavily
modified log files, but that&#8217;s not really my problem. While releasing
this may seem irresponsible on my part, anyone with a basic knowledge of
programming could accomplish this task on their own. This doesn&#8217;t really
seem to be the sort of thing that demands responsible disclosure,
either. I personally think that signing logs is outrageously stupid
because <em>everyone rips CDs just for themselves, right? Right?</em></p>

<p><a href="https://github.com/torque/Z.bundle">I&#8217;ve put the relevant code on github</a> (with some improvement),
and I&#8217;ve even included a <a href="https://github.com/torque/Z.bundle/releases/tag/v0.0.0">pre-compiled 32-bit bundle</a>, though in
theory building it is as simple as opening the project in Xcode and
pressing the build button. It&#8217;s certainly not polished, has absolutely
no error handling, and it might leak memory, but it works.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn:disclaimer">Some names may or may not have been changed to protect
the guilty. <a href="#fnref:disclaimer" title="Return to article" class="reversefootnote">&#8617;</a></li>

<li id="fn:readtwice">The extra read is a verification pass because apparently
it is extremely naïve to just trust the disk drive to read what is
actually on the CD. <a href="#fnref:readtwice" title="Return to article" class="reversefootnote">&#8617;</a></li>

<li id="fn:hexrays">The decompiler, Hex-Rays, is not included. <a href="#fnref:hexrays" title="Return to article" class="reversefootnote">&#8617;</a></li>

<li id="fn:dangerzone">We, of course, do not actually do this because illegally
acquiring a copy of IDA and Hex-Rays would probably be a felony, and
possibly constitute grand larceny, if you are the type of person who
treats software as property. <a href="#fnref:dangerzone" title="Return to article" class="reversefootnote">&#8617;</a></li>

<li id="fn:anditdumb">There&#8217;s additionally no point because as has already been
stated, I can&#8217;t read x86 assembly (or any other kind of assembly for
that matter), and the decompiled psuedocode turns out to be a
labyrinthine horror (assuming that the binary blob was even being
disassembled correctly). What a shock. <a href="#fnref:anditdumb" title="Return to article" class="reversefootnote">&#8617;</a></li>

<li id="fn:oreven">At least one of the errors I encountered with my 32-bit
builds of XLD was one related to it refusing to execute memory. I
suspect that this may have been the real reason I couldn&#8217;t get my
personal builds to work, though on other occasions, I saw a crash within
the memory (at least the disassembly blurb provided by lldb didn&#8217;t exist
anywhere in the disassembled LogChecker binary). Basically, I don&#8217;t know
what the hell was going on. <a href="#fnref:oreven" title="Return to article" class="reversefootnote">&#8617;</a></li>

</ol>
</div></section>
          </article>
        </div>
      </div>
      <div class="push"></div>
    </div>
    <footer>
      <div class="content-wrap"><span><a href="/" class="index-link">« Index</a></span><br><span class="about">Copywrong 2016</span><br><span class="poweredby">Powered by&nbsp;<a href="http://wintersmith.io">Wintersmith</a>. Colorscheme stolen shamelessly from&nbsp;<a href="https://github.com/chriskempson/base16">base16-eighties</a>.</span>
      </div>
    </footer>
    <script type="text/javascript" src="/js/footnotemagic.js"></script>
  </body>
</html>